// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: playlist.proto

package proto

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	proto1 "main/internal/microservices/image/proto"
	proto "main/internal/microservices/session/proto"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	PlaylistService_Create_FullMethodName           = "/PlaylistService/Create"
	PlaylistService_Get_FullMethodName              = "/PlaylistService/Get"
	PlaylistService_GetUserPlaylists_FullMethodName = "/PlaylistService/GetUserPlaylists"
	PlaylistService_AddTrack_FullMethodName         = "/PlaylistService/AddTrack"
	PlaylistService_RemoveTrack_FullMethodName      = "/PlaylistService/RemoveTrack"
	PlaylistService_UpdatePreview_FullMethodName    = "/PlaylistService/UpdatePreview"
	PlaylistService_RemovePreview_FullMethodName    = "/PlaylistService/RemovePreview"
	PlaylistService_DeleteById_FullMethodName       = "/PlaylistService/DeleteById"
	PlaylistService_Like_FullMethodName             = "/PlaylistService/Like"
	PlaylistService_IsLike_FullMethodName           = "/PlaylistService/IsLike"
	PlaylistService_Unlike_FullMethodName           = "/PlaylistService/Unlike"
	PlaylistService_HasModifyAccess_FullMethodName  = "/PlaylistService/HasModifyAccess"
	PlaylistService_HasReadAccess_FullMethodName    = "/PlaylistService/HasReadAccess"
	PlaylistService_MakePrivate_FullMethodName      = "/PlaylistService/MakePrivate"
	PlaylistService_MakePublic_FullMethodName       = "/PlaylistService/MakePublic"
)

// PlaylistServiceClient is the client API for PlaylistService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlaylistServiceClient interface {
	Create(ctx context.Context, in *PlaylistBase, opts ...grpc.CallOption) (*PlaylistResponse, error)
	Get(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*PlaylistResponse, error)
	GetUserPlaylists(ctx context.Context, in *proto.UserId, opts ...grpc.CallOption) (*PlaylistsBase, error)
	AddTrack(ctx context.Context, in *PlaylistToTrackId, opts ...grpc.CallOption) (*empty.Empty, error)
	RemoveTrack(ctx context.Context, in *PlaylistToTrackId, opts ...grpc.CallOption) (*empty.Empty, error)
	UpdatePreview(ctx context.Context, in *PlaylistIdToImageUrl, opts ...grpc.CallOption) (*empty.Empty, error)
	RemovePreview(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*proto1.ImageUrl, error)
	DeleteById(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error)
	Like(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*empty.Empty, error)
	IsLike(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*IsLikedPlaylist, error)
	Unlike(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*empty.Empty, error)
	HasModifyAccess(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*HasAccess, error)
	HasReadAccess(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*HasAccess, error)
	MakePrivate(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error)
	MakePublic(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error)
}

type playlistServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPlaylistServiceClient(cc grpc.ClientConnInterface) PlaylistServiceClient {
	return &playlistServiceClient{cc}
}

func (c *playlistServiceClient) Create(ctx context.Context, in *PlaylistBase, opts ...grpc.CallOption) (*PlaylistResponse, error) {
	out := new(PlaylistResponse)
	err := c.cc.Invoke(ctx, PlaylistService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) Get(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*PlaylistResponse, error) {
	out := new(PlaylistResponse)
	err := c.cc.Invoke(ctx, PlaylistService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) GetUserPlaylists(ctx context.Context, in *proto.UserId, opts ...grpc.CallOption) (*PlaylistsBase, error) {
	out := new(PlaylistsBase)
	err := c.cc.Invoke(ctx, PlaylistService_GetUserPlaylists_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) AddTrack(ctx context.Context, in *PlaylistToTrackId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_AddTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) RemoveTrack(ctx context.Context, in *PlaylistToTrackId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_RemoveTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) UpdatePreview(ctx context.Context, in *PlaylistIdToImageUrl, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_UpdatePreview_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) RemovePreview(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*proto1.ImageUrl, error) {
	out := new(proto1.ImageUrl)
	err := c.cc.Invoke(ctx, PlaylistService_RemovePreview_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) DeleteById(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_DeleteById_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) Like(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_Like_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) IsLike(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*IsLikedPlaylist, error) {
	out := new(IsLikedPlaylist)
	err := c.cc.Invoke(ctx, PlaylistService_IsLike_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) Unlike(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_Unlike_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) HasModifyAccess(ctx context.Context, in *PlaylistToUserId, opts ...grpc.CallOption) (*HasAccess, error) {
	out := new(HasAccess)
	err := c.cc.Invoke(ctx, PlaylistService_HasModifyAccess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) HasReadAccess(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*HasAccess, error) {
	out := new(HasAccess)
	err := c.cc.Invoke(ctx, PlaylistService_HasReadAccess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) MakePrivate(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_MakePrivate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playlistServiceClient) MakePublic(ctx context.Context, in *PlaylistId, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, PlaylistService_MakePublic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlaylistServiceServer is the server API for PlaylistService service.
// All implementations must embed UnimplementedPlaylistServiceServer
// for forward compatibility
type PlaylistServiceServer interface {
	Create(context.Context, *PlaylistBase) (*PlaylistResponse, error)
	Get(context.Context, *PlaylistToUserId) (*PlaylistResponse, error)
	GetUserPlaylists(context.Context, *proto.UserId) (*PlaylistsBase, error)
	AddTrack(context.Context, *PlaylistToTrackId) (*empty.Empty, error)
	RemoveTrack(context.Context, *PlaylistToTrackId) (*empty.Empty, error)
	UpdatePreview(context.Context, *PlaylistIdToImageUrl) (*empty.Empty, error)
	RemovePreview(context.Context, *PlaylistId) (*proto1.ImageUrl, error)
	DeleteById(context.Context, *PlaylistId) (*empty.Empty, error)
	Like(context.Context, *PlaylistToUserId) (*empty.Empty, error)
	IsLike(context.Context, *PlaylistToUserId) (*IsLikedPlaylist, error)
	Unlike(context.Context, *PlaylistToUserId) (*empty.Empty, error)
	HasModifyAccess(context.Context, *PlaylistToUserId) (*HasAccess, error)
	HasReadAccess(context.Context, *PlaylistId) (*HasAccess, error)
	MakePrivate(context.Context, *PlaylistId) (*empty.Empty, error)
	MakePublic(context.Context, *PlaylistId) (*empty.Empty, error)
	mustEmbedUnimplementedPlaylistServiceServer()
}

// UnimplementedPlaylistServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPlaylistServiceServer struct {
}

func (UnimplementedPlaylistServiceServer) Create(context.Context, *PlaylistBase) (*PlaylistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPlaylistServiceServer) Get(context.Context, *PlaylistToUserId) (*PlaylistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPlaylistServiceServer) GetUserPlaylists(context.Context, *proto.UserId) (*PlaylistsBase, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserPlaylists not implemented")
}
func (UnimplementedPlaylistServiceServer) AddTrack(context.Context, *PlaylistToTrackId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTrack not implemented")
}
func (UnimplementedPlaylistServiceServer) RemoveTrack(context.Context, *PlaylistToTrackId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTrack not implemented")
}
func (UnimplementedPlaylistServiceServer) UpdatePreview(context.Context, *PlaylistIdToImageUrl) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePreview not implemented")
}
func (UnimplementedPlaylistServiceServer) RemovePreview(context.Context, *PlaylistId) (*proto1.ImageUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePreview not implemented")
}
func (UnimplementedPlaylistServiceServer) DeleteById(context.Context, *PlaylistId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteById not implemented")
}
func (UnimplementedPlaylistServiceServer) Like(context.Context, *PlaylistToUserId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Like not implemented")
}
func (UnimplementedPlaylistServiceServer) IsLike(context.Context, *PlaylistToUserId) (*IsLikedPlaylist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLike not implemented")
}
func (UnimplementedPlaylistServiceServer) Unlike(context.Context, *PlaylistToUserId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlike not implemented")
}
func (UnimplementedPlaylistServiceServer) HasModifyAccess(context.Context, *PlaylistToUserId) (*HasAccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasModifyAccess not implemented")
}
func (UnimplementedPlaylistServiceServer) HasReadAccess(context.Context, *PlaylistId) (*HasAccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasReadAccess not implemented")
}
func (UnimplementedPlaylistServiceServer) MakePrivate(context.Context, *PlaylistId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakePrivate not implemented")
}
func (UnimplementedPlaylistServiceServer) MakePublic(context.Context, *PlaylistId) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakePublic not implemented")
}
func (UnimplementedPlaylistServiceServer) mustEmbedUnimplementedPlaylistServiceServer() {}

// UnsafePlaylistServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlaylistServiceServer will
// result in compilation errors.
type UnsafePlaylistServiceServer interface {
	mustEmbedUnimplementedPlaylistServiceServer()
}

func RegisterPlaylistServiceServer(s grpc.ServiceRegistrar, srv PlaylistServiceServer) {
	s.RegisterService(&PlaylistService_ServiceDesc, srv)
}

func _PlaylistService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistBase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).Create(ctx, req.(*PlaylistBase))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).Get(ctx, req.(*PlaylistToUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_GetUserPlaylists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(proto.UserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).GetUserPlaylists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_GetUserPlaylists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).GetUserPlaylists(ctx, req.(*proto.UserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_AddTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToTrackId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).AddTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_AddTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).AddTrack(ctx, req.(*PlaylistToTrackId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_RemoveTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToTrackId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).RemoveTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_RemoveTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).RemoveTrack(ctx, req.(*PlaylistToTrackId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_UpdatePreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistIdToImageUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).UpdatePreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_UpdatePreview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).UpdatePreview(ctx, req.(*PlaylistIdToImageUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_RemovePreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).RemovePreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_RemovePreview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).RemovePreview(ctx, req.(*PlaylistId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_DeleteById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).DeleteById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_DeleteById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).DeleteById(ctx, req.(*PlaylistId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_Like_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).Like(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_Like_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).Like(ctx, req.(*PlaylistToUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_IsLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).IsLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_IsLike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).IsLike(ctx, req.(*PlaylistToUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_Unlike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).Unlike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_Unlike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).Unlike(ctx, req.(*PlaylistToUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_HasModifyAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistToUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).HasModifyAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_HasModifyAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).HasModifyAccess(ctx, req.(*PlaylistToUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_HasReadAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).HasReadAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_HasReadAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).HasReadAccess(ctx, req.(*PlaylistId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_MakePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).MakePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_MakePrivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).MakePrivate(ctx, req.(*PlaylistId))
	}
	return interceptor(ctx, in, info, handler)
}

func _PlaylistService_MakePublic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaylistId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaylistServiceServer).MakePublic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PlaylistService_MakePublic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaylistServiceServer).MakePublic(ctx, req.(*PlaylistId))
	}
	return interceptor(ctx, in, info, handler)
}

// PlaylistService_ServiceDesc is the grpc.ServiceDesc for PlaylistService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PlaylistService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PlaylistService",
	HandlerType: (*PlaylistServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PlaylistService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PlaylistService_Get_Handler,
		},
		{
			MethodName: "GetUserPlaylists",
			Handler:    _PlaylistService_GetUserPlaylists_Handler,
		},
		{
			MethodName: "AddTrack",
			Handler:    _PlaylistService_AddTrack_Handler,
		},
		{
			MethodName: "RemoveTrack",
			Handler:    _PlaylistService_RemoveTrack_Handler,
		},
		{
			MethodName: "UpdatePreview",
			Handler:    _PlaylistService_UpdatePreview_Handler,
		},
		{
			MethodName: "RemovePreview",
			Handler:    _PlaylistService_RemovePreview_Handler,
		},
		{
			MethodName: "DeleteById",
			Handler:    _PlaylistService_DeleteById_Handler,
		},
		{
			MethodName: "Like",
			Handler:    _PlaylistService_Like_Handler,
		},
		{
			MethodName: "IsLike",
			Handler:    _PlaylistService_IsLike_Handler,
		},
		{
			MethodName: "Unlike",
			Handler:    _PlaylistService_Unlike_Handler,
		},
		{
			MethodName: "HasModifyAccess",
			Handler:    _PlaylistService_HasModifyAccess_Handler,
		},
		{
			MethodName: "HasReadAccess",
			Handler:    _PlaylistService_HasReadAccess_Handler,
		},
		{
			MethodName: "MakePrivate",
			Handler:    _PlaylistService_MakePrivate_Handler,
		},
		{
			MethodName: "MakePublic",
			Handler:    _PlaylistService_MakePublic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "playlist.proto",
}
